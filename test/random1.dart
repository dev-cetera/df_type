// --- Generated by Gemeni 2.5 Pro ---

import 'dart:async';
import 'package:test/test.dart';
import 'package:df_type/df_type.dart';

enum TestEnum { one, two, three }

enum AnotherEnum { alpha, beta }

void main() {
  group('Type Checking Utilities', () {
    test('isNullable should correctly identify nullable types', () {
      expect(isNullable<String>(), isFalse);
      expect(isNullable<String?>(), isTrue);
      expect(isNullable<int>(), isFalse);
      expect(isNullable<int?>(), isTrue);
      expect(isNullable<Null>(), isTrue);
      expect(isNullable<void>(), isTrue);
      expect(isNullable<dynamic>(), isTrue);
    });

    test('isSubtype should correctly identify subtype relationships', () {
      expect(isSubtype<int, num>(), isTrue);
      expect(isSubtype<num, int>(), isFalse);
      expect(isSubtype<List<int>, Iterable<int>>(), isTrue);
      expect(isSubtype<Iterable<int>, List<int>>(), isFalse);
      expect(isSubtype<Future<int>, Future<dynamic>>(), isTrue);
      expect(isSubtype<int Function(), Function>(), isTrue);
    });

    test('typeEquality should correctly identify equal types', () {
      expect(typeEquality<int, int>(), isTrue);
      expect(typeEquality<int, String>(), isFalse);
      expect(typeEquality<List<int>, List<int>>(), isTrue);
      expect(typeEquality<List<int>, List<double>>(), isFalse);
      expect(typeEquality<int?, int>(), isFalse);
    });
  });

  group('Type Conversion (`let...`) Utilities', () {
    test('letAsOrNull and castAsOrNull should cast safely', () {
      expect(letAsOrNull<String>('hello'), 'hello');
      expect(letAsOrNull<String>(123), isNull);
      expect(castAsOrNull<int>(123), 123);
      expect(castAsOrNull<int>('123'), isNull);
    });

    group('letOrNull', () {
      test('should convert to int', () {
        expect(letOrNull<int>('123'), 123);
        expect(letOrNull<int>('123.45'), 123);
      });
      test('should convert to double', () {
        expect(letOrNull<double>('123.45'), 123.45);
        expect(letOrNull<double>(123), 123.0);
      });
      test('should convert to bool', () {
        expect(letOrNull<bool>('true'), isTrue);
        expect(letOrNull<bool>('false'), isFalse);
        expect(letOrNull<bool>(''), isNull);
      });
      test('should convert to String', () {
        expect(letOrNull<String>(123), '123');
      });
    });

    group('letMapOrNull', () {
      test('should convert from a valid map', () {
        final input = {1: 'one', 2: 'two'};
        final result = letMapOrNull<String, String>(input);
        expect(result, {'1': 'one', '2': 'two'});
      });
      test('should parse a valid JSON string', () {
        final input = '{"key": "value", "num": 123}';
        final result = letMapOrNull<String, dynamic>(input);
        expect(result, {'key': 'value', 'num': 123});
      });
      test('should return null for invalid JSON string', () {
        expect(letMapOrNull<String, dynamic>('not json'), isNull);
      });
      test('should return empty map for empty string', () {
        expect(letMapOrNull<String, dynamic>(''), isEmpty);
      });
      test('should filter nulls when requested', () {
        final input = {'a': 1, 'b': null, 'c': '3'};
        final result = letMapOrNull<String, int>(input, filterNulls: true);
        expect(result, {'a': 1, 'c': 3});
      });
    });

    group('letListOrNull', () {
      test('should parse from a CSV string', () {
        expect(letListOrNull<int>('1, 2, 3'), [1, 2, 3]);
      });
      test('should convert from an existing iterable', () {
        expect(letListOrNull<String>([1, 2, 3]), ['1', '2', '3']);
      });
      test('should return null for non-collection inputs', () {
        expect(letListOrNull<int>(123), isNull);
        expect(letListOrNull<int>(true), isNull);
      });
      test('should use nullFallback to replace failed conversions', () {
        final input = ['1', 'two', null, '3'];
        final result = letListOrNull<int>(input, nullFallback: 0);
        expect(result, [1, 0, 0, 3]);
      });

      test('should filter out failed conversions when filterNulls is true', () {
        final input = ['1', 'two', null, '3'];
        final result = letListOrNull<int>(input, filterNulls: true);
        expect(result, [1, 3]);
      });
    });

    group('letEnumOrNull', () {
      test('should convert from string correctly', () {
        expect(letEnumOrNull('one', TestEnum.values), TestEnum.one);
        expect(letEnumOrNull('TWO', TestEnum.values), TestEnum.two);
        expect(letEnumOrNull(' four ', TestEnum.values), isNull);
      });
      test('should return null for non-string inputs', () {
        expect(letEnumOrNull(1, TestEnum.values), isNull);
        expect(letEnumOrNull(true, TestEnum.values), isNull);
      });
    });
  });

  group('DeepGet Utilities', () {
    final testData = {
      'user': {
        'name': 'Alice',
        'roles': ['admin', 'editor'],
      },
      'posts': [
        {'id': 1, 'title': 'First Post'},
        {'id': 2, 'title': 'Second Post'},
      ],
      '200': 'status ok',
    };

    test('deepGet should retrieve from string path', () {
      expect(testData.deepGet<String>('user.name'), 'Alice');
      expect(testData.deepGet<String>('posts.1.title'), 'Second Post');
      expect(testData.deepGet<String>('200'), 'status ok');
      expect(testData.deepGet<String>('user.email'), isNull);
    });

    test('deepGetFromSegments should retrieve from segment list', () {
      expect(
        testData.deepGetFromSegments<String>(['user', 'roles', 0]),
        'admin',
      );
      expect(testData.deepGetFromSegments<int>(['posts', 1, 'id']), 2);
    });
  });

  group('Extension Methods', () {
    test('ValueOfOnEnumExtension should find enum by name', () {
      expect(AnotherEnum.values.valueOf('alpha'), AnotherEnum.alpha);
      expect(AnotherEnum.values.valueOf('BETA'), AnotherEnum.beta);
      expect(AnotherEnum.values.valueOf('gamma'), isNull);
    });

    test('TryOrNullOnFunctionExtension should execute safely', () {
      int parseInt(String s) => int.parse(s);
      int throws() => throw Exception();

      expect(parseInt.tryOrNull<int>(['123']), 123);
      expect(parseInt.tryOrNull<int>(['abc']), isNull);
      expect(throws.tryOrNull<int>([]), isNull);
    });

    test('FutureOrExtension should work correctly', () {
      FutureOr<int> val = 10;
      FutureOr<int> fut = Future.value(20);

      expect(val.isFuture, isFalse);
      expect(val.isNotFuture, isTrue);
      expect(val.asNonFutureOrNull(), 10);
      expect(val.asFutureOrNull(), isNull);

      expect(fut.isFuture, isTrue);
      expect(fut.isNotFuture, isFalse);
      expect(fut.asNonFutureOrNull(), isNull);
      expect(fut.asFutureOrNull(), isA<Future<int>>());
      expect(fut.toFuture(), isA<Future<int>>());
    });
  });

  group('Asynchronous Helpers', () {
    group('consec', () {
      test('should handle synchronous values', () {
        final result = consec(10, (a) => a * 2);
        expect(result, 20);
      });
      test('should handle asynchronous values', () async {
        final result = await consec(Future.value(10), (a) => a * 2);
        expect(result, 20);
      });
      test('should handle mixed sync/async callback', () async {
        final result = await consec(10, (a) => Future.value(a * 2));
        expect(result, 20);
      });
      test('consec2 should handle multiple values', () async {
        final result = await consec2(
          10,
          Future.value('a'),
          (num, str) => '$str$num',
        );
        expect(result, 'a10');
      });
    });

    group('Waiter', () {
      test('should execute sync and async operations', () async {
        final waiter = Waiter<String>();
        waiter.add(() => 'sync');
        waiter.add(() async => 'async');
        final results = await waiter.wait();
        expect(results, orderedEquals(['sync', 'async']));
      });

      test('should handle add, addAll, remove, and clear', () {
        final waiter = Waiter<int>();
        Function op1 = () => 1;
        Function op2 = () => 2;
        Function op3 = () => 3;

        waiter.add(op1 as FutureOr<int> Function());
        expect(waiter.operations, hasLength(1));

        waiter.addAll([
          op2 as FutureOr<int> Function(),
          op3 as FutureOr<int> Function(),
        ]);
        expect(waiter.operations, hasLength(3));

        waiter.remove(op2);
        expect(waiter.operations, hasLength(2));

        waiter.clear();
        expect(waiter.operations, isEmpty);
      });

      test('should call onError callbacks on failure', () async {
        var errorCount = 0;
        final waiter = Waiter<int>(onError: (e, s) => errorCount++);
        waiter.add(() => throw Exception('test error'));

        await expectLater(
          () => waiter.wait(onError: (e, s) => errorCount++),
          throwsException,
        );

        expect(errorCount, 2);
      });
    });
  });
}
